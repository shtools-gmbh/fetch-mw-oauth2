{"version":3,"sources":["webpack://fetchMwOAuth2/webpack/universalModuleDefinition","webpack://fetchMwOAuth2/./src/base64.web.ts","webpack://fetchMwOAuth2/./src/error.ts","webpack://fetchMwOAuth2/./src/fetch-wrapper.ts","webpack://fetchMwOAuth2/./src/index.ts","webpack://fetchMwOAuth2/./src/util.ts","webpack://fetchMwOAuth2/webpack/bootstrap","webpack://fetchMwOAuth2/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","input","btoa","OAuthError","Error","message","oauth2Code","httpCode","super","this","options","token","grantType","accessToken","console","warn","refreshToken","expiresAt","activeRefresh","refreshTimer","scheduleRefresh","init","request","Request","fetchMw","req","fetch","next","getAccessToken","authenticatedRequest","clone","headers","set","response","ok","status","newToken","Date","now","getToken","err","onAuthError","clearTimeout","expiresIn","setTimeout","async","error","default","objToQueryString","Object","entries","map","key","value","undefined","encodeURIComponent","join","body","previousToken","grant_type","refresh_token","clientSecret","client_id","clientId","scope","username","userName","password","code","redirect_uri","redirectUri","code_verifier","codeVerifier","usesBasicAuth","basicAuthStr","Authorization","authResult","tokenEndpoint","method","jsonResult","json","httpError","errorMessage","error_description","statusText","access_token","expires_in","onTokenUpdate","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","call"],"mappings":"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","file":"fetch-mw-oauth2.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fetchMwOAuth2\"] = factory();\n\telse\n\t\troot[\"fetchMwOAuth2\"] = factory();\n})(self, function() {\nreturn ","/**\n * Encoding a string to base64 in a browser.\n */\nexport function encode(input: string): string {\n\n  return btoa(input);\n\n}\n","/**\n * An error class for any error the server emits.\n *\n * The 'code' property will have the oauth2 error type,\n * such as:\n * - invalid_request\n * - invalid_client\n * - invalid_grant\n * - unauthorized_client\n * - unsupported_grant_type\n * - invalid_scope\n */\nexport default class OAuthError extends Error {\n\n  oauth2Code: number;\n  httpCode: number;\n\n  constructor(message: string, oauth2Code: number, httpCode: number) {\n\n    super(message);\n\n    this.oauth2Code = oauth2Code;\n    this.httpCode = httpCode;\n\n  }\n\n}\n","import {\n  OAuth2Options as Options,\n  OAuth2Token as Token\n} from './types';\nimport { refreshToken } from './util';\n\nexport default class OAuth2 {\n\n  options: Options;\n  token: Token | null;\n\n  /**\n   * Keeping track of an active refreshToken operation.\n   *\n   * This will allow us to ensure only 1 such operation happens at any\n   * given time.\n   */\n  private activeRefresh: Promise<Token> | null;\n\n  /**\n   * Timer trigger for the next automated refresh\n   */\n  private refreshTimer: ReturnType<typeof setTimeout> | null;\n\n  constructor(options: Options & Partial<Token>, token: Token|null = null) {\n\n    if (!options.grantType && !token && !options.accessToken) {\n      throw new Error('If no grantType is specified, a token must be provided');\n    }\n    this.options = options;\n\n    // Backwards compatibility\n    if (options.accessToken) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[fetch-mw-oauth2] Specifying accessToken via the options argument ' +\n        'in the constructor of OAuth2 is deprecated. Please supply the ' +\n        'options in the second argument. Backwards compatability will be ' +\n        'removed in a future version of this library');\n      token = {\n        accessToken: options.accessToken,\n        refreshToken: options.refreshToken || null,\n        expiresAt: null,\n      };\n    }\n\n    this.token = token;\n    this.activeRefresh = null;\n    this.refreshTimer = null;\n\n    this.scheduleRefresh();\n\n  }\n\n  /**\n   * Does a fetch request and adds a Bearer / access token.\n   *\n   * If the access token is not known, this function attempts to fetch it\n   * first. If the access token is almost expiring, this function might attempt\n   * to refresh it.\n   */\n  async fetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n\n    // input might be a string or a Request object, we want to make sure this\n    // is always a fully-formed Request object.\n    const request = new Request(input, init);\n\n    return this.fetchMw(\n      request,\n      req => fetch(req)\n    );\n\n  }\n\n  /**\n   * This function allows the fetch-mw to be called as more traditional\n   * middleware.\n   *\n   * The function takes a Request object, and a next() function that\n   * represents the next 'fetch' function in the chain.\n   */\n  async fetchMw(request: Request, next: (request: Request) => Promise<Response>): Promise<Response> {\n\n    const accessToken = await this.getAccessToken();\n\n    let authenticatedRequest = request.clone();\n    authenticatedRequest.headers.set('Authorization', 'Bearer '  + accessToken);\n    let response = await next(authenticatedRequest);\n\n    if (!response.ok && response.status === 401) {\n\n      const newToken = await this.refreshToken();\n\n      authenticatedRequest = request.clone();\n      authenticatedRequest.headers.set('Authorization', 'Bearer '  + newToken.accessToken);\n      response = await next(authenticatedRequest);\n\n    }\n    return response;\n\n  }\n\n  /**\n   * Returns current token information.\n   *\n   * There result object will have:\n   *   * accessToken\n   *   * expiresAt - when the token expires, or null.\n   *   * refreshToken - may be null\n   */\n  async getToken(): Promise<Token> {\n\n    if (this.token && (this.token.expiresAt === null || this.token.expiresAt > Date.now())) {\n\n      // The current token is still valid\n      return this.token;\n\n    }\n\n    return this.refreshToken();\n\n  }\n\n  /**\n   * Returns an access token.\n   *\n   * If the current access token is not known, it will attempt to fetch it.\n   * If the access token is expiring, it will attempt to refresh it.\n   */\n  async getAccessToken(): Promise<string> {\n\n    const token = await this.getToken();\n    return token.accessToken;\n\n  }\n\n  /**\n   * Forces an access token refresh\n   */\n  async refreshToken(): Promise<Token> {\n\n    if (this.activeRefresh) {\n      // If we are currently already doing this operation,\n      // make sure we don't do it twice in parallel.\n      return this.activeRefresh;\n    }\n\n    this.activeRefresh = refreshToken(this.options, this.token);\n\n    try {\n      const token = await this.activeRefresh;\n      this.token = token;\n      this.scheduleRefresh();\n      return token;\n    } catch (err) {\n      if (this.options.onAuthError) {\n        this.options.onAuthError(err);\n      }\n      throw err;\n    } finally {\n      // Make sure we clear the current refresh operation.\n      this.activeRefresh = null;\n    }\n\n  }\n\n  private scheduleRefresh() {\n\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n\n    if (!this.token || !this.token.expiresAt || !this.token.refreshToken) {\n      // If we don't know when the token expires, or don't have a refresh_token, don't bother.\n      return;\n    }\n\n    const expiresIn = this.token.expiresAt - Date.now();\n\n    // We only schedule this event if it happens more than 2 minutes in the future.\n    if (expiresIn < 120*1000) {\n      return;\n    }\n\n    // Schedule 1 minute before expiry\n    this.refreshTimer = setTimeout(async () => {\n      try {\n        await this.refreshToken();\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('[fetch-mw-oauth2] error while doing a background OAuth2 auto-refresh', err);\n      }\n    }, expiresIn - 60*1000);\n\n  }\n\n}\n","export {\n  default as default,\n  default as fetchMwOAuth2,\n  default as OAuth2\n} from './fetch-wrapper';\n\nexport {\n  OAuth2Options,\n  OAuth2Token\n} from './types';\n\nexport {\n  default as OAuth2Error\n}from './error';\n","import {\n  AccessTokenRequest,\n  OAuth2Token,\n  OAuth2Options,\n} from './types';\nimport { encode as base64Encode } from './base64';\nimport OAuthError from './error';\n\n/**\n * A simple querystring.stringify alternative, so we don't need to include\n * another dependency for the browser\n */\nexport function objToQueryString(input: {[s: string]: string|undefined}): string {\n\n  return Object.entries(input).map( ([key, value]) => {\n\n    if (value === undefined) {\n      // skip\n      return '';\n    } else {\n      return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n    }\n  }).join('&');\n\n}\n\n/**\n * This function either obtains a new access token, or refreshes an old\n * one.\n */\nexport async function refreshToken(options: OAuth2Options, token: OAuth2Token | null): Promise<OAuth2Token> {\n\n  // The request body for the OAuth2 token endpoint\n  let body: AccessTokenRequest;\n\n  const previousToken = token;\n\n  if (previousToken?.refreshToken) {\n    body = {\n      grant_type: 'refresh_token',\n      refresh_token: previousToken.refreshToken\n    };\n    if ((options as any).clientSecret === undefined) {\n      // If there is no secret, it means we need to send the clientId along\n      // in the body.\n      body.client_id = options.clientId;\n    }\n\n  } else {\n\n    switch (options.grantType) {\n\n      case 'client_credentials':\n        body = {\n          grant_type: 'client_credentials',\n        };\n        if (options.scope) {\n          body.scope = options.scope.join(' ');\n        }\n        break;\n      case 'password':\n        body = {\n          grant_type: 'password',\n          username: options.userName,\n          password: options.password,\n        };\n        if (options.scope) {\n          body.scope = options.scope.join(' ');\n        }\n        break;\n      case 'authorization_code' :\n        body = {\n          grant_type: 'authorization_code',\n          code: options.code,\n          redirect_uri: options.redirectUri,\n          client_id: options.clientId,\n          code_verifier: options.codeVerifier,\n        };\n        break;\n      default :\n        if (typeof options.grantType === 'string') {\n          throw new Error('Unknown grantType: ' + options.grantType);\n        } else {\n          throw new Error('Cannot obtain an access token if no \"grantType\" is specified');\n        }\n        break;\n    }\n\n  }\n\n  const headers: {[s: string]: string} = {\n    'Content-Type'  : 'application/x-www-form-urlencoded',\n  };\n\n  let usesBasicAuth = false;\n  if ((options as any).clientSecret !== undefined) {\n    usesBasicAuth = true;\n    const basicAuthStr = base64Encode(options.clientId + ':' + (options as any).clientSecret);\n    headers.Authorization = 'Basic ' + basicAuthStr;\n  }\n\n  const authResult = await fetch(options.tokenEndpoint, {\n    method: 'POST',\n    headers,\n    body: objToQueryString(body),\n  });\n\n  const jsonResult = await authResult.json();\n\n  if (!authResult.ok) {\n\n    // If we failed with a refresh_token grant_type, we're going to make one\n    // more attempt doing a full re-auth\n    if (body.grant_type === 'refresh_token' && options.grantType) {\n      return refreshToken(options, null);\n    }\n\n    const httpError = authResult.status;\n    let errorMessage;\n\n    let oauth2Code;\n    if (jsonResult.error) {\n      errorMessage = 'OAuth2 error ' + jsonResult.error + '.';\n      if (jsonResult.error_description) {\n        errorMessage += ' ' + jsonResult.error_description;\n      }\n      oauth2Code = jsonResult.error;\n    } else {\n      errorMessage = 'HTTP Error ' + authResult.status + ' ' + authResult.statusText;\n      if (authResult.status === 401 && usesBasicAuth) {\n        errorMessage += '. It\\'s likely that the clientId and/or clientSecret was incorrect';\n      }\n      oauth2Code = null;\n    }\n    throw new OAuthError(errorMessage, oauth2Code, httpError);\n  }\n\n\n  const newToken: OAuth2Token = {\n    accessToken: jsonResult.access_token,\n    expiresAt: jsonResult.expires_in ? Date.now() + (jsonResult.expires_in * 1000) : null,\n    refreshToken: jsonResult.refresh_token ? jsonResult.refresh_token : null,\n  };\n  if (options.onTokenUpdate) {\n    options.onTokenUpdate(newToken);\n  }\n\n  return newToken;\n\n}\n\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(22);\n"],"sourceRoot":""}